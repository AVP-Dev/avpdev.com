---
// src/pages/blog/index.astro

// Явно указываем, что эта страница должна быть сгенерирована статически.
export const prerender = true;

import { getCollection } from 'astro:content';
import BaseLayout from '../../layouts/BaseLayout.astro';
import BlogCard from '../../components/BlogCard.astro';
import FeaturedPostCard from '../../components/FeaturedPostCard.astro';

// Получаем все посты, исключая черновики
const allPosts = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});

// Сортируем посты по дате от новых к старым
allPosts.sort((a, b) => new Date(b.data.pubDate).valueOf() - new Date(a.data.pubDate).valueOf());

const hasPosts = allPosts.length > 0;
const latestPost = hasPosts ? allPosts[0] : null;
const otherPosts = hasPosts ? allPosts.slice(1) : [];

// Собираем все уникальные теги для кнопок-фильтров 
const allTags = [...new Set(allPosts.flatMap(post => post.data.tags))];
---
<BaseLayout
  title="blog_page_title"
  description="blog_page_desc"
>
  <section id="blog-list" class="blog-page">
    <div class="container">
      <div class="blog-header fade-in">
        <h1 class="section-title" data-lang="blog_h1"></h1>
        <p class="section-subtitle" data-lang="blog_p"></p>
      </div>
      
      <!-- Отображаем последний пост отдельно -->
      {hasPosts && latestPost && (
        <div class="featured-post-section fade-in">
          <h2 data-lang="blog_latest_post"></h2>
          <FeaturedPostCard post={latestPost} />
        </div>
      )}

      <!-- Отображаем остальные посты и фильтры -->
      {(otherPosts.length > 0 || allTags.length > 0) && (
        <div class="posts-list-section fade-in" style="transition-delay: 200ms;">
          
          {otherPosts.length > 0 && <h2 data-lang="blog_other_posts"></h2>}
          
          <div class="filters-container">
            <div class="search-wrapper">
              <i class="fas fa-search search-icon" aria-hidden="true"></i>
              <input type="search" id="blog-search" data-lang-placeholder="blog_search_placeholder" placeholder="Поиск по статьям..." aria-label="Поиск по статьям">
            </div>
            {allTags.length > 0 && (
              <div class="tags-filter" id="tags-filter">
                <button class="tag-filter-btn active" data-tag="all" data-lang="filter_all"></button>
                {allTags.map(tag => (
                  <button class="tag-filter-btn" data-tag={tag.toLowerCase()}>{tag}</button>
                ))}
              </div>
            )}
          </div>
          
          {otherPosts.length > 0 && (
            <div id="posts-grid" class="portfolio-grid blog-grid">
              {otherPosts.map(post => (
                <BlogCard post={post} />
              ))}
            </div>
          )}
        </div>
      )}
      
      <p id="no-results-message" class="no-results-message" data-lang="blog_no_results" style="display: none;"></p>

      {!hasPosts && (
        <p class="no-results-message" data-lang="blog_no_posts_yet"></p>
      )}

    </div>
  </section>
</BaseLayout>

<script>
  document.addEventListener('astro:page-load', () => {
    const searchInput = document.getElementById('blog-search');
    const tagsContainer = document.getElementById('tags-filter');
    const postsGrid = document.getElementById('posts-grid');
    const noResultsMessage = document.getElementById('no-results-message');

    // Если одного из ключевых элементов нет, скрипт не должен работать
    if (!postsGrid || !searchInput || !tagsContainer || !noResultsMessage) {
      return;
    }

    // УЛУЧШЕНИЕ: Используем querySelectorAll для более надежного выбора карточек.
    // Это делает код нечувствительным к будущим изменениям верстки (например, к появлению div-оберток).
    const allCards = Array.from(postsGrid.querySelectorAll('.blog-card-link'));

    let currentTag = 'all';
    let currentQuery = '';

    function filterPosts() {
      let visibleCount = 0;

      allCards.forEach(card => {
        const title = card.dataset.title || '';
        const description = card.dataset.description || '';
        const tags = card.dataset.tags || '';

        const matchesQuery = currentQuery === '' || title.includes(currentQuery) || description.includes(currentQuery);
        const matchesTag = currentTag === 'all' || (tags && tags.split(',').includes(currentTag));

        const isVisible = matchesQuery && matchesTag;
        
        // Показываем или скрываем саму карточку (элемент <a>)
        card.style.display = isVisible ? '' : 'none';

        if (isVisible) {
          visibleCount++;
        }
      });

      noResultsMessage.style.display = visibleCount === 0 ? 'block' : 'none';
    }

    searchInput.addEventListener('input', (e) => {
      currentQuery = (e.target as HTMLInputElement).value.toLowerCase().trim();
      filterPosts();
    });

    tagsContainer.addEventListener('click', (e) => {
      const target = e.target;
      if (target instanceof HTMLElement && target.matches('.tag-filter-btn')) {
        tagsContainer.querySelector('.active')?.classList.remove('active');
        target.classList.add('active');
        currentTag = target.dataset.tag || 'all';
        filterPosts();
      }
    });
  });
</script>
